<div align="center">
  <img src="https://raw.githubusercontent.com/rob-smallshire/markuplift/master/docs/images/logo.png" alt="Markuplift Logo" width="300">

  # Markuplift

  **A configurable XML and HTML formatter for Python**

  [![CI](https://img.shields.io/github/actions/workflow/status/rob-smallshire/markuplift/ci.yml?branch=master&label=CI)](https://github.com/rob-smallshire/markuplift/actions/workflows/ci.yml)
  [![PyPI version](https://img.shields.io/pypi/v/markuplift)](https://pypi.org/project/markuplift/)
  [![Python versions](https://img.shields.io/pypi/pyversions/markuplift)](https://pypi.org/project/markuplift/)
  [![License](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/rob-smallshire/markuplift/blob/master/LICENSE)
  [![Downloads](https://img.shields.io/pypi/dm/markuplift)](https://pypi.org/project/markuplift/)
</div>

Markuplift provides flexible, configurable formatting of XML and HTML documents. Unlike basic pretty-printers, Markuplift gives you complete control over how your markup is formatted through user-defined predicates for block vs inline elements, whitespace handling, and custom text content formatters.

## Key Features

- **Specialized formatters** - `Html5Formatter` for HTML with HTML5 defaults, `XmlFormatter` for strict XML compliance
- **Type-safe configuration** - Use `ElementType` enum for better type safety and IDE support
- **Configurable element classification** - Define block/inline elements using XPath expressions or Python predicates
- **Flexible whitespace control** - Normalize, preserve, or strip whitespace on a per-element basis
- **External formatter integration** - Pipe element text content through external tools (e.g., js-beautify, prettier)
- **Comprehensive format options** - Control indentation, attribute wrapping, self-closing tags, and more
- **CLI and Python API** - Use from command line or integrate into your Python applications

## Understanding Block vs Inline Elements

> **Important:** Markuplift's "block" and "inline" concepts are about **formatting and whitespace handling**, in the source, not CSS layout or browser rendering. These classifications determine how Markuplift adds newlines and indentation around elements.

### Block Elements
**Block elements** get their own lines with proper indentation. Typical examples include structural elements like `<p>`, `<div>`, `<ul>`, `<li>`, `<h1>`, etc.

### Inline Elements
**Inline elements** flow within text content without adding line breaks. Typical examples include text formatting elements like `<em>`, `<strong>`, `<code>`, `<a>`, etc.

### Example: Why This Matters

**Input (messy):**
```html
<p>This paragraph contains <em>emphasized text</em> and <strong>bold text</strong>.</p><ul><li>First item with <code>inline code</code></li><li>Second item</li></ul>
```

**With proper block/inline classification:**
```html
<p>This paragraph contains <em>emphasized text</em> and <strong>bold text</strong>.</p>
<ul>
  <li>First item with <code>inline code</code></li>
  <li>Second item</li>
</ul>
```

Notice how:
- **Block elements** (`<p>`, `<ul>`, `<li>`) get their own lines and indentation
- **Inline elements** (`<em>`, `<strong>`, `<code>`) stay within the text flow
- Whitespace is added **around** elements, not **within** their text content

**What would happen with wrong classification:**
```html
<!-- If <em> and <strong> were treated as block: -->
<p>This paragraph contains
  <em>emphasized text</em>
   and
  <strong>bold text</strong>
.</p>
<!-- Breaks the text flow! -->

<!-- If <ul> and <li> were treated as inline: -->
<p>This paragraph contains <em>emphasized text</em> and <strong>bold text</strong>.</p><ul><li>First item with <code>inline code</code></li><li>Second item</li></ul>
<!-- Poor readability! -->
```

## Quick Start

### Installation

Install from PyPI using pip:
```bash
pip install markuplift
```

Or using uv (recommended for modern Python development):
```bash
uv add markuplift
```

For development installation with all dependencies:
```bash
git clone https://github.com/rob-smallshire/markuplift.git
cd markuplift
uv sync --all-extras
```

### CLI Usage

{{ cli_demo_content }}

### Python API Example

Here's how to format HTML with proper block/inline classification and whitespace preservation in `<code>` and `<pre>` elements:

```python
{{ python_api_basic_source }}
```

**Output:**
```html
{{ documentation_output }}
```

### Real-World Example

Here's Markuplift formatting a complex article structure with mixed content:

**Input** (`article_example.html`):
```html
{{ article_input }}
```

```python
{{ real_world_article_source }}
```

**Output:**
```html
{{ article_output }}
```

### Parameterized Custom Predicates

You can create predicates that accept parameters, making them reusable for different situations. Here are examples that show how to customize formatting based on programming languages and CSS classes:

```python
{{ code_in_documentation_sections_source }}
```

**Usage:**
```python
{{ complex_predicates_usage_source }}
```

**Input** (`complex_predicates_example.html`):
```html
{{ complex_predicates_input }}
```

**Output:**
```html
{{ complex_predicates_output }}
```

### Attribute Value Formatting

Markuplift can format complex attribute values like CSS styles:

**Input** (`attribute_formatting_example.html`):
```html
{{ attribute_formatting_input }}
```

```python
{{ num_css_properties_source }}

{{ css_multiline_formatter_source }}

{{ attribute_formatting_source }}
```

**Output:**
```html
{{ attribute_formatting_output }}
```

### XML Document Formatting

For XML documents, use `XmlFormatter` which provides XML-strict parsing and escaping:

```python
{{ xml_document_formatting_source }}
```

**Input** (`xml_document_example.xml`):
```xml
{{ xml_document_input }}
```

**Output:**
```xml
{{ xml_document_output }}
```

## Choosing the Right Formatter

- **`Html5Formatter`** - For HTML documents. Includes sensible HTML5 defaults for block/inline elements, HTML5-compliant parsing, and HTML-friendly escaping
- **`XmlFormatter`** - For XML documents. Provides strict XML compliance, XML-compliant escaping, and no assumptions about element types
- **`Formatter`** - For advanced use cases requiring full control over parsing and escaping strategies

## Use Cases

Markuplift is perfect for:

- **Web development** - Format HTML templates and components with `Html5Formatter` for consistent styling and HTML5 compliance
- **API documentation** - Use `XmlFormatter` for XML API specs and configuration files with strict validation
- **Content management** - Standardize markup in CMS systems with custom element classification rules
- **Code generation** - Format dynamically generated XML/HTML with precise control using `ElementType` enums
- **CI/CD pipelines** - Ensure consistent markup formatting across your codebase with CLI integration
- **Legacy system migration** - Clean up and standardize markup from legacy systems with flexible predicate rules
- **Static site generation** - Format template files and generated content with specialized formatters
- **Diffing and version control** - Improve readability of markup changes with consistent formatting

## License

Markuplift is released under the [MIT License](https://github.com/rob-smallshire/markuplift/blob/master/LICENSE).

## Contributing

Contributions are welcome! Please see our [Contributing Guide](CONTRIBUTING.md) for details on:

- Setting up the development environment
- Running tests and linting
- Submitting pull requests
- Reporting issues